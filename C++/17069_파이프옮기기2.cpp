#include <iostream>
using namespace std;

int main() {
	int N;
	cin >> N;
	
	int house[N][N];
	for(int i = 0; i < N; i++){
		for(int j = 0; j < N; j++){
			cin >> house[i][j];
		}
	} // 벽지의 상태 입력
	
	long long int dp[3][N][N]; // 3차원 배열 dp -> 가로 일 때, 세로일 때, 대각선일 때의 경로 값을 각각 저장해주기 위해(같이 저장하면 잘못 겹칠 수 있음)
	for(int k = 0; k < 3; k++){
		for(int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				dp[k][i][j] = 0;
			}
		}
	} // 0으로 초기화
	dp[0][0][1] = 1; // 끝 점을 기준으로 초기화(초기 상태)
	
	int move[3][2] = {{1,0},{0,1},{1,1}}; // 대각선으로는 모두 이동할 수 있기 때문에 가로, 세로, 대각선이 가로와 세로로 이동할 수 있는지 여부만 표시(이동 가능하면 1, 아니면 0)
	int dir[2][2] = {{0,1},{1,0}}; // 가로 이동, 세로 이동
	for(int x = 0; x < N; x++){ // x좌표
		for(int y = 0; y < N; y++){ // y좌표
			for(int k = 0; k < 3; k++){ // 가로, 세로, 대각선
				for(int m = 0; m < 2; m++){ // 가로 또는 세로로 이동하기 위함
					if(move[k][m] == 1){ // 이동이 가능하다면
						int dx = x+dir[m][0], dy = y+dir[m][1]; // 좌표 계산
						if(dx < N && dy < N && house[dx][dy] == 0){ // 좌표가 범위 안에 존재해야 하고 이동하는 지점의 값이 1이 아니여야 함(0이여야 함)
							dp[m][dx][dy] += dp[k][x][y]; // m은 바뀐 상태, k는 현재 상태(현재 상태의 경로의 수를 바뀐 상태 경로의 수에 더해줌) 
						}
					}
				}
        
        			// 대각선으로 이동하는 경우
				if(x+1 < N && y+1 < N){ // 범위 체크
					if(house[x+1][y] == 0 && house[x][y+1] == 0 && house[x+1][y+1] == 0){ // 3개의 면이 모두 1이 아니여야 함(모두 0)
						dp[2][x+1][y+1] += dp[k][x][y]; // 대각선 상태에 이전 상태의 값을 더해 줌
					}
				}
			}
		}
	}

	cout << dp[0][N-1][N-1] + dp[1][N-1][N-1] + dp[2][N-1][N-1]; // 최종 상태 출력(가로로 끝났을 때, 세로로 끝났을 때, 대각선으로 끝났을 때의 상태 모두 더해주어야 함)
	
	return 0;
}
